import heapq
import sys

INF = int(1e9)
input = sys.stdin.readline

count = 1
while (True):
    N = int(input())
    if N == 0:
        break
    cave = []
    for i in range(N):
        cave.append(list(map(int, input().split())))
    distance = [[INF] * N for _ in range(N)]
    graph = [[[] for _ in range(N)] for _ in range(N)]
    
    for i in range(N):
        for j in range(N):
            if i + 1 <= N - 1:
                graph[i][j].append((i + 1, j, cave[i + 1][j]))
            if i - 1 >= 0:
                graph[i][j].append((i - 1, j, cave[i - 1][j]))
            if j + 1 <= N - 1:
                graph[i][j].append((i, j + 1, cave[i][j + 1]))
            if j - 1 >= 0:
                graph[i][j].append((i, j - 1, cave[i][j- 1]))
              
    def dijkstra(startX, startY):
        q = []
        heapq.heappush(q, (cave[0][0], startX, startY))
        distance[startX][startY] = cave[0][0]
        while q:
            dist, nowX, nowY = heapq.heappop(q)
            if distance[nowX][nowY] < dist:
                continue
            for i in graph[nowX][nowY]:
                cost = dist + i[2]
                if cost < distance[i[0]][i[1]]:
                    distance[i[0]][i[1]] = cost
                    heapq.heappush(q, (cost, i[0], i[1]))
    
    dijkstra(0, 0)
    
    print("Problem %d: %d" %(count, distance[N - 1][N - 1]))

    count += 1

###################################################################
훨씬 더 간편 
import heapq
import sys

INF = int(1e9)
input = sys.stdin.readline
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

count = 1
while (True):
    N = int(input())
    if N == 0:
        break
    cave = []
    for i in range(N):
        cave.append(list(map(int, input().split())))
    distance = [[INF] * N for _ in range(N)] 
             
    def dijkstra():
        q = []
        heapq.heappush(q, (cave[0][0], 0, 0))
        distance[0][0] = cave[0][0]
        while q:
            dist, nowX, nowY = heapq.heappop(q)
            if dist < distance[nowX][nowY]:
                continue
            for i in range(4):
                new_X = nowX + dx[i]
                new_Y = nowY + dy[i]
                if 0 <= new_X <= N - 1 and 0 <= new_Y <= N - 1:
                    cost = dist + cave[new_X][new_Y]
                    if cost < distance[new_X][new_Y]:
                        distance[new_X][new_Y] = cost
                        heapq.heappush(q, (cost, new_X, new_Y))
                
    dijkstra()
    
    print("Problem %d: %d" %(count, distance[N - 1][N - 1]))

    count += 1