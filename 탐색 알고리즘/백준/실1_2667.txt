DFS
def dfs(x, y):
    if x < 0 or y < 0 or x >= N or y >= N:
        return 0 
    if graph[x][y] == 1:
        graph[x][y] = -1
        return 1 + dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1)              
    else:
        return 0
      
N = int(input())
graph = []
cnt = []
for i in range(N):
    graph.append(list(map(int, input())))
for i in range(N):
    for k in range(N):
        count = dfs(i, k)
        if count > 0:
            cnt.append(count)
print(len(cnt))
cnt.sort()
for i in cnt:
    print(i)

##################################################################
BFS
from collections import deque

def bfs(x, y):
    queue = deque()
    queue.append((x, y))
    count = 0
    while queue:
        x, y = queue.popleft()
        if x < 0 or y < 0 or x >= N or y >= N:
            continue
        if graph[x][y] == 1:
            count += 1
            graph[x][y] = -1
            queue.append((x + 1, y))
            queue.append((x - 1, y))
            queue.append((x, y + 1))
            queue.append((x, y - 1))
    return count
            
N = int(input())
graph = []
for i in range(N):
    graph.append(list(map(int, input())))
cnt = []
for i in range(N):
    for k in range(N):
        count = bfs(i, k)
        if count > 0:
            cnt.append(count)

print(len(cnt))
cnt.sort()
for i in cnt:
    print(i)